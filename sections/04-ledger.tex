\section{The \oscoin{} Ledger}

\subsection{Users}

Users are identified by public keys. Adding a user is done using the
\[
    \tx{registeruser}{U}
  \]
transaction, where $U$ is a public key, which must be signed by $U$.

\subsection{Projects}
\label{s:projects}

A project $P$ is a tuple:
\[
    P = \tuple{P_a, P_h, P_s}
\]
where $P_{a}$ is the project's address and unique identifier, $P_h$ is
the project's current hash and $P_s$ is the canonical project source
URL.

The project address, an integer, is used to identify the project, as
well as to send \oscoin{} to it. Each project has an account balance
identified by project address. The project hash is a digest of the
project's source code at the time it is entered in the
ledger. Finally, the project URL is there for convenience, as a means
to fetch the source code.  It must be noted that the source code
retrieved from $P_s$ must always hash to $P_h$, otherwise the project
is considered invalid.

\subsubsection{Registration and ownership} Projects need to be
registered on the ledger before they can participate in the
network. This can be done with the
\[
    \tx{registerproject}{P_a, P_s}
\]
transaction, singed by a user $U$ (who becomes a project owner). The
transaction is valid as long as the address isn't already in use. Note
that the execution of this transaction locks a small \oscoin{} deposit
from $U$'s wallet, to prevent abandoned projects from
accumulating. Once executed, the project is instantiated to
$P = \tuple{P_a, P_h, P_s}$ with $P_h = \varnothing$.

After registration the project's \emph{owner set} is $\{U\}$, this can
be extended with:
\[
    \tx{addowner}{U}
\]
where $U$ is an existing user not currently in the owner set.
When a project is no longer in use, it is possible to unregister it from the
ledger with
\[
    \tx{unregister}{P_a}.
\]
which must be signed by an owner. Execution of this transaction
returns the registration deposit to the user who originally registered
the project.

Projects registered on the ledger can be retrieved from the state $\state$ by
using the project address, formally: $\state(P_a) \to P$.

\subsubsection{Checkpointing} Any project in active development will see its
source code change regularly. This means the project hash $P_h$ will quickly
become out of sync with the project's latest state and will need updating. This
is done via the
\[
    \tx{checkpoint}{P_a, P_h', s, C^*, D^*}
\]
% TODO: what is the use of s?
transaction, where $P_h'$ is the new project hash, $s$ is the URL to
retrieve the source code from, and $C^*$ is hash-linked-list of
\emph{contributions}, and $D^*$ is a list of \emph{dependency updates}.

Contributions are tuples:
\[
   \tuple{\field{C}{prev}, \field{C}{commit}, \field{C}{author}, \field{C}{signoff}}
\]
where:
\begin{itemize}
\item $\field{C}{prev}$ is the hash of the previous contribution, or
  $\varnothing$ if this is the first contribution to the whole
  project. Note that $C^*$'s first item must be linked to the last
  contribution in the project's previous checkpoint.
\item $\field{C}{commit}$ is the hash of the corresponding commit,
\item $\field{C}{author}$ is the author of the contribution,
\item $\field{C}{sig}$ is author's signature of the commit hash,
\item $\field{C}{signoff}$ is the \emph{signoff user}, which must be
  one of the current owners of the project.
\end{itemize}
A contribution must be signed by the signoff user. This signals the
the contribution has been reviewed/verified by this maintainer. The
checkpoint as a whole must also be signed by a current owner.

Because all changes to a project's source code are signalled by
checkpoints, it is possible to reconstruct a full hash-linked list of
contributions for the entire project. When cross-referenced with the
project's repository, this gives a full historical breakdown of who
authored which code, and which project maintainer signed it off.

There are two main uses for this. First of all the individual
contributions in a checkpoint are used as edges in the network graph
$\netgraph$ used to compute \osrank{} (\S~\ref{s:osrank}).
Second, because contributions reference users, combined with the
subjective trust system (\S~\ref{s:web-of-trust}), this gives a
particular user a view into the trustworthiness of the project as a
whole, based on the contributions it is built out of. A user may judge
a project as trustworthy (for example when deciding to add it as a
dependency), if all the users involved in all the contributions (or at
least the signoffs) have a relatively high trust score, according to
his trust-network.

\label{s:dependencies}
Conceptually, a project $P$ depends on a project $P'$ if it is an
``input'' to $P$ in some way: $P$ references $P'$ or parts of
$P'$ in its source code, or $P'$ is a build/dev/test dependency,
etc. For example if a project used the purely functional package
manager \emph{Nix} (see~\cite{nix}), then the dependencies declared on
\oscoin{} should probably map one to one with the Nix
dependencies. Dependencies are an important input to the \osrank{}
metric.

The dependencies updates list $D^*$ is a list of \emph{dependency
  updates}, which are one of
\[
    \depend(P'_a, n) \quad \text{or} \quad \undepend(P'_a, n)
\]
which refers to the $n$th checkpoint of a project $P'$ ($0$-indexed
from the first checkpoint). The $\depend$ update adds a new dependency
while the $\undepend$ update removes a dependency. The updates are
processed in order with $\depend$ only being valid if it adds a
dependency that the project doesn't already depend on and $\undepend$
only being valid for current dependencies. The checkpoint is invalid
if the update list contains duplicates.

As a project owner, adding a dependency signals a variety of things
(partly dependent of the nature of the project):
\begin{itemize}
\item they have verified that $P$ indeed depends on this specific
  version of $P'$,
\item that $P'$ is suitable as a dependency for $P$, \eg{} if $P$ has
  very high security requirements, that $P'$ fulfils these.
\end{itemize}

% TODO: talk about how the web-of-trust parallel system can assign
% trust scores to individual dependency txs, which means that a user
% can form a subjective score on not only a project, but it's whole
% set of transitive dependencies too.

\def\posnat{\mathbb{N}_{\geq 1}}

\subsection{\oscoin{} transfers}

Both users and projects are associated with an \oscoin{} balance.  The
set of \emph{balance addresses} is the coproduct of user keys and
project IDs:
\[
\accAddrs = \users + \projs.
\]
Each address is associated to a balance:
\[
\bal(a) \in \posnat \mid a \in \accAddrs.
\]
Transfers to and from balances are performed by the
\[
\tx{transfer}{x,y,n} \mid x,y \in \accAddrs, n \in \mathbb{N}_{\geq 1}
\]
transaction. If $x \in \users$ then the transaction is valid if signed
by $x$. If $x \in \projs$ then the transaction is valid if it is
signed by any one of the owners of the project $x$. In any case, for
the transaction to be valid $\bal(x) \leq n$ must hold, and after the
transaction $x$'s balance is decremented by $n$ and $y$'s is
incremented by $n$.

