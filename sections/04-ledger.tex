\section{The Oscoin Ledger}
\label{s:ledger}

% TODO: Introduce the state and transactions.

\subsection{Supply}

The supply of \oscoin{} is subject to an inflation $\protocol_{\iota} \in
\mathbb{N}$, carried out by the protocol every epoch $e$, and determined by a
logarithmic function $f : e \to e_{\iota}$, such that $\lim_{e \to \infty} f(e)
= 0$.

\subsection{Accounts}
\label{s:accounts}

% TODO: Reference Ethereum's account model

Currency is held in \emph{accounts} which can be unlocked by the signature of
the account holder. Accounts have addresses which are used to send and receive
\oscoin{}. The set of all accounts is known as $\mathcal{A}$.

Accounts are created by sending \oscoin{} to them (Section \ref{s:sending}),
and are removed from the ledger when their balance reaches zero.

The account balance $A_b$ of an account $A$ is held in the state $\state$, and
can be accessed with the account address $A_a$. Formally, $\state(A_a) \to A_b$.

\subsection{Projects}
\label{s:projects}

A project $P$ is a tuple:
\[
    P = \tuple{P_a, P_h, P_s}
\]
where $P_{a}$ is the project's address and unique identifier, $P_h$ is
the project's current hash and $P_s$ is the canonical project source
URL.

% TODO: Project address is not an integer
The project address, an integer, is used to identify the project, as
well as to send \oscoin{} to it. Each project has an account balance
identified by project address. The project hash is a digest of the
project's source code at the time it is entered in the
ledger. Finally, the project URL is there for convenience, as a means
to fetch the source code.  It must be noted that the source code
retrieved from $P_s$ must always hash to $P_h$, otherwise the project
is considered invalid.

\subsubsection{Registration and ownership} Projects need to be
registered on the ledger before they can participate in the
network. This can be done with the
\[
    \tx{register}{P_a, P_s}
\]
transaction, signed by a key $k_1$ which must be used when updating the project
at a later time. The transaction is valid as long as the address $P_a$ isn't
already in use, and $P_s$ is a valid URL.

On successful execution, the transaction locks a small amount of \oscoin{} from
the account associated with $k_1$. This helps ensures that abandonned projects
don't clutter the ledger.  Once executed, the project is instantiated to $P =
\tuple{P_a, P_h, P_s}$ with $P_h = \varnothing$.

The project $P$'s current key set $P_K$ is $\{k_1\}$. This can be extended
with:
\[
    \tx{addkey}{k}
\]
where $k$ is a valid key not present in $P_K$. Keys can also be removed, with:
\[
    \tx{removekey}{k}
\]
where $k$ is a key present in the $P_K$.
When a project is no longer in use, it is possible to unregister it from the
ledger with
\[
    \tx{unregister}{P_a},
\]
which must be signed by an owner ($k_1$ in the above example).
Execution of this transaction returns the registration deposit to the account
associated with the registration key.

Projects registered on the ledger can be retrieved from the state $\state$ by
using the project address, formally: $\state(P_a) \to P$.

\subsubsection{Checkpointing} Any project in active development will see its
source code change regularly. This means the project hash $P_h$ will quickly
become out of sync with the project's latest state and will need updating. This
is done via the
\[
    \tx{checkpoint}{P_a, P_{h'}, P_{s'}, C^*, D^*}
\]
% TODO: what is the use of s?
transaction, where $P_{h'}$ is the new project hash, $P_{s'}$ is the URL to
retrieve the source code from, $C^*$ is a hash-linked-list of
\emph{contributions}, and $D^*$ is a list of \emph{dependency updates}.

Contributions are tuples:
\[
   \tuple{\field{C}{prev}, \field{C}{commit}, \field{C}{author}, \field{C}{signoff}}
\]
where:
\begin{itemize}
\item $\field{C}{prev}$ is the hash of the previous contribution, or
  $\varnothing$ if this is the first contribution to the whole
  project. Note that $C^*$'s first item must be linked to the last
  contribution in the project's \emph{previous} checkpoint, such that no
  gaps between contributions exist.
\item $\field{C}{commit}$ is the hash of the corresponding commit,
\item $\field{C}{author}$ is the author of the contribution,
\item $\field{C}{sig}$ is the author's signature of $\field{C}{commit}$.
\item $\field{C}{signoff}$ is the \emph{signoff key}, which must be $\in P_K$.
\end{itemize}
A contribution must be signed by the signoff user. This signals the
the contribution has been reviewed/verified by this maintainer. The
checkpoint as a whole must also be signed by a key in the project key set.

Because all changes to a project's source code are signalled by
checkpoints, it is possible to reconstruct a full hash-linked list of
contributions for the entire project. When cross-referenced with the
project's repository, this gives a full historical breakdown of who
authored which code, and which project maintainer signed it off.

There are two main uses for this. First of all the individual
contributions in a checkpoint are used as edges in the network graph
$\netgraph$ used to compute \osrank{} (Section \ref{s:osrank}).
Second, because contributions reference users, combined with the
subjective trust system (\S~\ref{s:web-of-trust}), this gives a
particular user a view into the trustworthiness of the project as a
whole, based on the contributions it is built out of. A user may judge
a project as trustworthy (for example when deciding to add it as a
dependency), if all the users involved in all the contributions (or at
least the signoffs) have a relatively high trust score, according to
his trust-network.
% TODO: Remove reference to web of trust

\label{s:dependencies}
Conceptually, a project $P$ depends on a project $P'$ if it is an
``input'' to $P$ in some way: $P$ references $P'$ or parts of
$P'$ in its source code, or $P'$ is a build/test dependency.
For example if a project used the purely functional package
manager \emph{Nix} \cite{nix}, then the dependencies declared on
\oscoin{} should probably map one to one with the Nix
dependencies. Dependencies are an important input to the \osrank{}
metric.

The dependencies updates list $D^*$ is a list of \emph{dependency
  updates}, which are one of
\[
    \depend(P'_a, n) \quad \text{or} \quad \undepend(P'_a, n)
\]
which refers to the $n$th checkpoint of a project $P'$ ($0$-indexed
from the first checkpoint). The $\depend$ update adds a new dependency
while the $\undepend$ update removes a dependency. The updates are
processed in order with $\depend$ only being valid if it adds a
dependency that the project doesn't already have and $\undepend$
only being valid for current dependencies. The checkpoint is invalid
if the update list contains duplicates.

As a project owner, adding a dependency signals a variety of things
(partly dependent of the nature of the project):
\begin{itemize}
\item they have verified that $P$ indeed depends on this specific
  version of $P'$,
\item that $P'$ is suitable as a dependency for $P$, \eg{} if $P$ has
  very high security requirements, that $P'$ fulfils these.
\end{itemize}

% TODO: talk about how the web-of-trust parallel system can assign
% trust scores to individual dependency txs, which means that a user
% can form a subjective score on not only a project, but it's whole
% set of transitive dependencies too.

\def\posnat{\mathbb{N}_{\geq 1}}

\subsection{Sending \oscoin{}}
\label{s:sending}

Each user is associated with an \oscoin{} balance. Projects are associated with
two accounts, the first is the \emph{project account} and is controlled by the
owners. The second is the \emph{project fund}, and is controlled by smart
contracts (see \S \ref{s:smart-contracts}). The set of \emph{balance addresses}
is the coproduct of the set of user keys and the set of project addresses:
\[
\accAddrs = \users + \projs.
\]

Each address is associated to a balance:
\[
\bal(a) \in \posnat \mid a \in \accAddrs.
\]

Transfers to and from balances are performed by the
\[
\tx{transfer}{x,y,n} \mid x,y \in \accAddrs, n \in \posnat
\]
transaction. If $x \in \users$ then the transaction is valid if signed by
$x$. If $x \in \projs$ then the transaction is valid if it is signed by a
project owner. In any case, for the transaction to be valid $\bal(x) \geq n$
must hold, and after the transaction $x$'s balance is decremented by $n$ and
$y$'s is incremented by $n$.

