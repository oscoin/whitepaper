\section{The Oscoin Ledger}
\label{s:ledger}

\def\posnat{\mathbb{N}_{\geq 1}}

The \oscoin{} network is composed of a set of nodes, or \emph{replicas}, which
execute a distributed protocol. Together, these nodes form a \emph{Replicated
State Machine} with a set of states $\state_0, \ldots, \state_n$, a transition
function $\Xi$, a set of input blocks $B_0, \ldots, B_n$ or ``chain'' where
$B_0$ is the ``genesis block'', and a set of outputs.

The \oscoin{} ledger, formally $\ledger$, is the ordered set of all
transactions agreed upon by the network. The ledger can be updated by submitting
a valid transaction to the network. Transactions operate on the current state
$\state$ of the ledger, which is a materialized view of all processed transactions.

The transactions available on the ledger are described in this section, as well
as how they affect the state $\state$.

\subsection{Supply}

The supply of \oscoin{} is subject to an increase $B_r > 0$ carried out by the
protocol every epoch, following a fixed supply curve. This ensures a continuous
flow of \oscoin{} into the treasury (Section \ref{s:treasury}), to reward work
in the network.

\subsection{Accounts}
\label{s:accounts}

Currency (\oscoin{}) is held in \emph{accounts} which can be unlocked by the
signature of the account holder. Accounts have addresses which are used to send
and receive \oscoin{}. This model follows the design of Ethereum \cite{ethereum}
rather than Bitcoin's \emph{utxo} model \cite{bitcoin}.

Accounts are created by transfering \oscoin{} to them (Section \ref{s:transfering}),
and are removed from the ledger when their balance reaches zero. The set of all
accounts is known as $\accounts$.

The account balance $A_b$ of an account $A$ is held in the state $\state$, and
can be accessed with the account address $A_a$. Formally, $\state(A_a) \to A_b$.

Accounts also have an associated \emph{smart contract} (Section
\ref{s:smart-contracts}), formally $\field{A}{contract}$ which is used to
validate and process transfers of \oscoin{} to and from the account.

\subsection{Transfering \oscoin{}}
\label{s:transfering}

Each account in $\accounts$ is associated with an \oscoin{} balance:
\[
    \bal(a) \in \posnat \mid a \in \accounts.
\]
Transfers to and from accounts are performed with
\[
    \tx{transfer}{x,y,n} \mid x,y \in \accounts, n \in \posnat
\]
where $x$ is the account from which to withdraw the funds, $y$ is the deposit
address, and $n$ is the amount of \oscoin{} to transfer.  The transaction is
valid so long as $\bal(x) \geq n$ holds, and the contracts attached to $x$ and
$y$ authorize the transfer (Section \ref{s:smart-contracts}).

\subsection{Projects}
\label{s:projects}

A project $P$ is a tuple:
\[
    P = \tuple{P_a, P_h, P_s}
\]
where $P_{a}$ is the project's address and unique identifier, $P_h$ is
the project's current hash and $P_s$ is the canonical project source
URL.

The project address, an alphanumerical string, is used to uniquely identify the
project when transacting on the ledger. Each project has a special account
associated with its address called the \emph{project fund}. The project hash is
a digest of the project's source code at the time it is entered in the ledger.
Finally, the project URL is there for convenience, as a means to fetch the
source code.  It must be noted that the source code retrieved from $P_s$ must
always hash to $P_h$, otherwise the project is considered invalid.

\subsubsection{Registration and ownership} Projects need to be
registered on the ledger before they can participate in the
network. This can be done with the
\[
    \tx{register}{P_a, P_s}
\]
transaction, signed by a key $k_1$ which must be used when updating the project
at a later time. The transaction is valid as long as the address $P_a$ isn't
already in use, and $P_s$ is a valid URL.

On successful execution, the transaction locks a small amount of \oscoin{} from
the account associated with $k_1$. This helps ensures that abandonned projects
don't clutter the ledger.  Once executed, the project is instantiated to $P =
\tuple{P_a, P_h, P_s}$ with $P_h = \varnothing$.

The project $P$'s current key set $P_K$ is $\{k_1\}$. This can be extended
with:
\[
    \tx{addkey}{P_a, k}
\]
where $k$ is a valid key not present in $P_K$. Keys can also be removed, with:
\[
    \tx{removekey}{P_a, k}
\]
where $k$ is a key present in $P_K$.  When a project is no longer in use, it
can be unregistered from the ledger with
\[
    \tx{unregister}{P_a},
\]
which must be signed by an owner ($k_1$ in the above example).
Execution of this transaction returns the registration deposit to the account
associated with the registration key.

Projects registered on the ledger can be retrieved from the registry $\registry$ by
using the project address, formally: $\registry(P_a) \to P$.

\subsubsection{Checkpointing} \label{s:checkpointing} Any project in active
development will see its source code change regularly. This means the project
hash $P_h$ will quickly become out of sync with the project's latest state and
will need updating. This is done via the
\[
    \tx{checkpoint}{P_a, P_{h'}, P_{s'}, C^*, D^*}
\]
transaction, where $P_{h'}$ is the new project hash, $P_{s'}$ is the URL to
retrieve the source code from, $C^*$ is a hash-linked-list of
\emph{contributions}, and $D^*$ is a list of \emph{dependency updates}.

Contributions are tuples:
\[
   \tuple{\field{C}{prev}, \field{C}{commit}, \field{C}{author}, \field{C}{signoff}}
\]
where:
\begin{itemize}
\item $\field{C}{prev}$ is the hash of the previous contribution, or
  $\varnothing$ if this is the first contribution to the whole
  project. Note that $C^*$'s first item must be linked to the last
  contribution in the project's \emph{previous} checkpoint, such that no
  gaps between contributions exist.
\item $\field{C}{commit}$ is the hash of the corresponding commit,
\item $\field{C}{author}$ is the author of the contribution,
\item $\field{C}{sig}$ is the author's signature of $\field{C}{commit}$.
\item $\field{C}{signoff}$ is the \emph{signoff key}, which must be $\in P_K$.
\end{itemize}
A contribution must be signed by the signoff user. This signals the
the contribution has been reviewed/verified by this maintainer. The
checkpoint as a whole must also be signed by a key in the project key set.

Because all changes to a project's source code are signalled by checkpoints, it
is possible to reconstruct a full hash-linked list of contributions for the
entire project. When cross-referenced with the project's repository, this gives
a full historical breakdown of who authored which code, and which project
maintainer signed it off.  This makes the project history auditable and
tamper-proof, as well as providing valuable information to the \osrank{}
algorithm. Note that only the contribution \emph{metadata} is stored on-chain.

\label{s:dependencies}
Conceptually, a project $P$ depends on a project $P'$ if it is an
``input'' to $P$ in some way: $P$ references $P'$ or parts of
$P'$ in its source code, or $P'$ is a build/test dependency.
For example if a project used the purely functional package
manager \emph{Nix} \cite{nix}, then the dependencies declared on
\oscoin{} should probably map one to one with the Nix
dependencies. Dependencies are an important input to the \osrank{}
metric.

The dependencies updates list $D^*$ is a list of \emph{dependency
  updates}, which are one of
\[
    \depend(P'_a, n) \quad \text{or} \quad \undepend(P'_a, n)
\]
which refers to the $n$th checkpoint of a project $P'$ ($0$-indexed
from the first checkpoint). The $\depend$ update adds a new dependency
while the $\undepend$ update removes a dependency. The updates are
processed in order with $\depend$ only being valid if it adds a
dependency that the project doesn't already have and $\undepend$
only being valid for current dependencies. The checkpoint is invalid
if the update list contains duplicates.

As a project owner, adding a dependency signals a variety of things
(partly dependent of the nature of the project):
\begin{itemize}
\item they have verified that $P$ indeed depends on this specific
  version of $P'$,
\item that $P'$ is suitable as a dependency for $P$, \eg{} if $P$ has
  very high security requirements, that $P'$ fulfils these.
\end{itemize}

\subsection{Smart contracts}

Finally, the ledger enables certain transactions to be mediated by smart contracts.
We dedicate the following section to this topic, showing how projects can automate
fund distribution as well as specify access policies.

