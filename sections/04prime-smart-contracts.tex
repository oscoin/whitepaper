\section{Project smart contracts}
\label{s:smart-contracts}

Most transactions relating to a project can be signed by any one of the
project's owners. This includes transferring funds to and from the project's
account. In order to ensure that funds distributed through \osrank{} (and
possibly donations) are spent in a responsible manner, the protocol deposits
these into a separate account, the \emph{project fund}. The protocol requires
that transfers from the project fund only be issued from within \emph{smart
  contracts}, functions written in a special purpose programming language which
triggers when certain events arise. When a contributor decides to contribute
code to a project, she may inspect the contracts currently in place (and under
what conditions they may be updated, etc.), so that she may be assured to be
remunerated for her work.

The most important contract for a project is the one used to distribute rewards
to contributors. This function is invoked every epoch, if the project gets a
payout according to it's \osrank{}. The function is called with two arguments:
$p$ is a dictionary containing the project data and $f \in \posnat$ represents
the amount of \oscoin{} currently in the project fund.

When a project is first registered its reward distribution function is set to a
no-op. This means that no transactions will take place; funds will just
accumulate in the project fund.

Once the owners have decided on a policy, they may issue a transaction to update
this function. For example, the project owners may decide that all contributors
should get an equal share of the reward:

\begin{algorithmic}[1]
\Procedure{onReward}{$p, f$}
\State $s \gets f \sslash \fn{count}{\prop{p}{contributors}}$
\For{$c \gets \prop{p}{contributors}$}
  \State $\tx{transfer}{\prop{p}{addr}, \prop{c}{addr}, s}$
\EndFor
\EndProcedure
\end{algorithmic}

Code updates are issued using
\[
    \tx{projectcontract}{s, c, v}
\]
transactions, signed by a project owner, where $s$ is the \emph{slot} to be
updated, $c$ is the code for the new function, and $v$ is a set of \emph{votes}:
a collection of signatures the owner has collected for the update. The previous
function is an example that would be used for the $\mathtt{onReward}$ slot.

Of course the owners cannot just update contracts whenever they want, to
whatever they like. How contracts can be updated is controlled by another slot:
$\mathtt{validContractUpdate}$. This is a function which takes 2 arguments: $p$,
the project data, and $v$, the list of public keys which signed votes for the
contract update transaction. The default code at this slot is:

\begin{algorithmic}[1]
\Procedure{validContractUpdate}{$p, v$}
\State \textbf{return} $\{ \prop{o}{addr} \mid o \gets \prop{p}{owners} \} \subseteq v$
\EndProcedure
\end{algorithmic}
which specifies that all the current owners must sign any contract update.

In order to specify that contract updates must be accepted by a majority of all
contributors, the code at this slot could be updated to:

\begin{algorithmic}[1]
\Procedure{validContractUpdate}{$p, v$}
\State $h \gets \fn{count}{\prop{p}{contributors}} \sslash 2$
\State $v' \gets \{ \prop{c}{addr} \mid c \gets \prop{p}{contributors} \} \cap v$
\State \textbf{return} $\fn{count}{v'} > 1 + h$
\EndProcedure
\end{algorithmic}

The exact specification of the contract language, and which built-in functions
are available, will be specified in a subsequent paper.
