% TODO(james):
% - merge with ledger sections
% - add bounty example

\section{Smart contracts}
\label{s:smart-contracts}

\newcommand{\handler}[1]{\textsc{\small#1}}

In order to ensure that funds distributed to projects by the \oscoin{}
treasury, as well as funds received as donations are spent responsibly and
transparently, the protocol sends them to a special type of account, a
\emph{project fund}, which is an account controlled by an updatable \emph{smart
contract}.
In addition, the protocol requires that transfers from the project fund only be
issued from within the fund's smart contract. When a contributor decides to
contribute code to a project, she may inspect the contract currently in place,
and under what conditions it may be updated, so that she may be assured to be
remunerated for her work.

\subsection{Definition}
A smart contract is a set of functions, or \emph{handlers}, invoked as part
of regular transaction processing. Certain transactions, such as $\mathsf{transfer}$
make use of smart contracts to extend their behavior and allow projects to
program interactions around their governance, ownership or finances.

\subsection{Receiving \oscoin{}}

When a transfer of \oscoin{} is received by a project, the smart contract
attached to that project's fund is invoked. The specific handler that is
called in the smart contract depends on \emph{sender}: for \oscoin{} received
from the treasury system, the \handler{receiveReward} handler is called, while
for transfers received from any other source, the \handler{receiveTransfer}
handler is called. This allows projects to handle funds received by the treasury
differently than funds received as donations, for example.

\subsubsection{Rewards from the treasury}

The \handler{receiveReward} handler is invoked every $\epoch$ blocks, for
projects getting a reward. The function is called with three arguments: $p$ is
a dictionary containing the project data, $r \in \posnat$ represents the amount
of \oscoin{} that is awarded to the project this epoch and $k \in \mathbb{N}$ is the
current epoch. The function must return a \emph{distribution}, a set of tuples
assigning a number of \oscoin{} to various accounts. The protocol checks the
function doesn't distribute more than $r$.

When a project is first registered, \handler{receiveReward} returns the empty
distribution, that is, the \oscoin{} is burnt:
\begin{algorithmic}[0]
    \Procedure{receiveReward}{$p, r, k$}
        \State \textbf{return} $\varnothing$
    \EndProcedure
\end{algorithmic}

Once the owners have decided on a policy, they may issue a transaction to update
this handler. For example, the project owners may decide that all contributors
should get an equal share of the reward, with the remainder getting deposited
into the project fund:

\begin{algorithmic}[0]
    \Procedure{receiveReward}{$p, r, k$}
        \State $n \gets |\prop{p}{contributors}|$
        \State $q \gets r \sslash n$
        \State $m \gets r \mod n$
        \State $x \gets \{ (\prop{c}{addr}, q) \mid c \gets \prop{p}{contributors} \}$
        \State \textbf{return} $x \cup \{ (\prop{p}{fund}, m) \}$
    \EndProcedure
\end{algorithmic}

\subsubsection{Transfers and donations}

When a transfer of \oscoin{} is received from a source other than the treasury,
the \handler{receiveTransfer} handler is invoked. This function takes the same
three arguments as \handler{receiveReward}, plus a fourth argument $s$ which
represents the sender or ``source'' account of the transfer. The function is
expected to return a distribution, just like \handler{receiveReward}. Initially,
this handler is set to simply transfer the funds to the project fund:
\medskip
\begin{algorithmic}[0]
    \Procedure{receiveTransfer}{$p, r, k, s$}
        \State \textbf{return} $\{ (\prop{p}{fund}, r) \}$
    \EndProcedure
\end{algorithmic}

\subsection{Contract function updates}

Contract updates are issued using the
\[
    \tx{updatecontract}{P_a, h, c, \nu, v}
\]
transaction, signed by a project owner, where $h$ is the \emph{handler} to be
updated, $c$ is the code for the new handler, $v$ is a set of \emph{votes}: a
collection of signatures the owner has collected for the update, and $\nu$ is a
\emph{nonce} to prevent replay attacks with votes. The conditions under which
the transaction is considered valid are specified in the
\handler{validContractUpdate} handler. This is a function which takes two
arguments: $p$, the project data, and $v$, the list of public keys which signed
votes for the contract update transaction. The function must return a boolean
value, stating if the update is valid ($\top$) or not ($\bot$).  The default
code of this handler is:
\begin{algorithmic}[0]
    \Procedure{validContractUpdate}{$p, v$}
        \State \textbf{return} $\{ \prop{o}{addr} \mid o \gets \prop{p}{owners} \} \subseteq v$
    \EndProcedure
\end{algorithmic}
which specifies that all the current owners must sign any contract update.

In order to specify that contract updates must be accepted by a majority of all
\emph{contributors}, this handler could be updated to:
\medskip
\begin{algorithmic}[0]
    \Procedure{validContractUpdate}{$p, v$}
        \State $h \gets |\prop{p}{contributors}| \sslash 2$
        \State $v' \gets \{ \prop{c}{addr} \mid c \gets \prop{p}{contributors} \} \cap v$
        \State \textbf{return} $|v'| > 1 + h$
    \EndProcedure
\end{algorithmic}

If the current \handler{validContractUpdate} handler returns ($\top$), the
contract update transaction is considered valid, and the handler specified in
the transaction is updated.

% TODO: Section on donations still needed?

\subsection{Ad-hoc spending}

The handler \handler{receiveTransfer} is useful for declaring a project's usual policy for distributing \oscoin{}
(\eg{} paying for bug-fixes and small contributions, etc.) However it is likely
that large donations will be redirected to the project fund rather than be
immediately distributed, so that more planning can take place before the funds
are spent.

To spend \oscoin{} from the project fund, $\mathsf{transfer}$ can be used with an
additional set of parameters:
\[
    \tx{transfer}{P_a, n, \nu, v} \mid n \in \posnat
\]
The transaction is valid if the handler \handler{sendTransfer} accepts
it. This function works in a similar way to \handler{validContractUpdate}. For
example, the function might specify that the project owners may spend a small
amount of \oscoin{} per month without seeking community agreement, but that
large sums need over half of contributors and donors to agree:
\medskip
\begin{algorithmic}[0]
    \Procedure{sendTransfer}{$p, n, v$}
        \If{$\fn{spentThisEpoch}{p} + n > 100$}
            \State $h \gets |\prop{p}{contributors} \cup \prop{p}{donors}| \sslash 2$
            \State $c' \gets \{ \prop{c}{addr} \mid c \gets \prop{p}{contributors} \}$
            \State $d' \gets \{ \prop{d}{addr} \mid d \gets \prop{p}{donors} \}$
            \State $v' \gets v \cap c' \cap d'$
            \State \textbf{return} $|v'| > 1 + h$
            \Else
            \State \textbf{return} $\top$
        \EndIf
    \EndProcedure
\end{algorithmic}

The exact specification of the contract language, and which built-in functions
are available, will be specified in a subsequent paper.
